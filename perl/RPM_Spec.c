/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2203 from the
 * contents of RPM_Spec.xs. Do not edit this file, edit RPM_Spec.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "RPM_Spec.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#undef Fflush
#undef Mkdir
#undef Stat
#undef Fstat

#include "rpmio.h"
#include "rpmiotypes.h"
#include "rpmmacro.h"

#include "rpmtypes.h"
#include "rpmtag.h"

#include "rpmfi.h"
#include "rpmts.h"

#include "rpmcli.h"

#include "rpmspec.h"
#include "rpmbuild.h"

#line 35 "RPM_Spec.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 87 "RPM_Spec.c"

XS(XS_RPM__Spec_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Spec_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "perlclass, specfile = NULL, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	perlclass = (char *)SvPV_nolen(ST(0));
	char *	specfile;
#line 34 "RPM_Spec.xs"
    rpmts ts = NULL;
    SV * passphrase = NULL;
    SV * rootdir = NULL;
    SV * cookies = NULL;
    SV * anyarch = 0;
    SV * force = 0;
    SV * verify = 0;
    int i;
#line 113 "RPM_Spec.c"

	if (items < 2)
	    specfile = NULL;
	else {
	    specfile = (char *)SvPV_nolen(ST(1));
	}
#line 43 "RPM_Spec.xs"
    for(i=2; i < items; i++) {
        if(strcmp(SvPV_nolen(ST(i)), "transaction") == 0) {
            i++;
            if (sv_isobject(ST(i)) && (SvTYPE(SvRV(ST(i))) == SVt_PVMG)) {
                ts = (rpmts)SvIV((SV*)SvRV(ST(i)));
                ts = rpmtsLink(ts, "RPM::Spec");  
            } else {
                croak( "transaction is not a blessed SV reference" );
                XSRETURN_UNDEF;
            } 
        } else if (strcmp(SvPV_nolen(ST(i)), "force") == 0) {
            i++;
            force = ST(i);
        } else if (strcmp(SvPV_nolen(ST(i)), "verify") == 0) {
            i++;
            verify = ST(i);
        } else if (strcmp(SvPV_nolen(ST(i)), "anyarch") == 0) {
            i++;
            anyarch = ST(i);
        } else if (strcmp(SvPV_nolen(ST(i)), "passphrase") == 0) {
            i++;
            passphrase = ST(i);
        } else if (strcmp(SvPV_nolen(ST(i)), "root") == 0) {
            i++;
            rootdir = ST(i);
        } else {
            warn("Unknown options in RPM::Spec->new, ignored");
            i++;
        }
    }
    if (!ts)
        ts = rpmtsCreate();
    PUTBACK;
    _newspec(ts, specfile, passphrase, rootdir, cookies, anyarch, force, verify);
    SPAGAIN;
    (void)rpmtsFree(ts);
    ts = NULL;
#line 158 "RPM_Spec.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Spec_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Spec_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "spec");
    {
	Spec	spec;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        spec = (Spec)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Spec::DESTROY() -- spec is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 85 "RPM_Spec.xs"
    spec = freeSpec(spec);
#line 186 "RPM_Spec.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_RPM__Spec_srcheader); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Spec_srcheader)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "spec");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Spec	spec;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        spec = (Spec)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Spec::srcheader() -- spec is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 91 "RPM_Spec.xs"
    initSourceHeader(spec, NULL); /* TODO NULL => @retval *sfp     srpm file list (may be NULL) */
    XPUSHs(sv_2mortal(sv_setref_pv(newSVpv("", 0), "RPM::Header", (void *)headerLink(spec->sourceHeader))));
#line 216 "RPM_Spec.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Spec_binheader); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Spec_binheader)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "spec");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Spec	spec;
#line 98 "RPM_Spec.xs"
    Package pkg;
#line 239 "RPM_Spec.c"

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        spec = (Spec)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Spec::binheader() -- spec is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 100 "RPM_Spec.xs"
    for (pkg = spec->packages; pkg != NULL; pkg = pkg->next)
        XPUSHs(sv_2mortal(sv_setref_pv(newSVpv("", 0), "RPM::Header", (void *)headerLink(pkg->header))));
#line 250 "RPM_Spec.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Spec_srcrpm); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Spec_srcrpm)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "spec");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Spec	spec;
#line 107 "RPM_Spec.xs"
    const char * srctag;
    const char * srcpath;
#line 274 "RPM_Spec.c"

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        spec = (Spec)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Spec::srcrpm() -- spec is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 110 "RPM_Spec.xs"
    srcpath = rpmGetPath("%{_srcrpmdir}", NULL);
    srctag = headerSprintf(
        spec->packages->header,
        "%{NAME}-%{VERSION}-%{RELEASE}",
        NULL,
        rpmHeaderFormats,
        NULL
    );
    XPUSHs(sv_2mortal(newSVpvf("%s/%s.%ssrc.rpm",
        srcpath,
        srctag,
        spec->noSource ? "no" : ""
        )));
    _free(srcpath);
    _free(srctag);
#line 298 "RPM_Spec.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Spec_binrpm); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Spec_binrpm)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "spec");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Spec	spec;
#line 130 "RPM_Spec.xs"
    Package pkg;
    const char * binFormat;
    char * binRpm;
    const char * path;
#line 324 "RPM_Spec.c"

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        spec = (Spec)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Spec::binrpm() -- spec is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 135 "RPM_Spec.xs"
    for(pkg = spec->packages; pkg != NULL; pkg = pkg->next) {
        if (pkg->fileList == NULL)
            continue;
        /* headerCopyTags(h, pkg->header, copyTags); */
        binFormat = rpmGetPath("%{_rpmfilename}", NULL);
        binRpm = headerSprintf(pkg->header, binFormat, rpmTagTable,
                   rpmHeaderFormats, NULL);
        _free(binFormat);
        path = rpmGetPath("%{_rpmdir}/", binRpm, NULL);
        XPUSHs(sv_2mortal(newSVpv(path, 0)));
        _free(path);
        _free(binRpm);
    }
#line 346 "RPM_Spec.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Spec_check); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Spec_check)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "spec, ts = NULL");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Spec	spec;
#line 153 "RPM_Spec.xs"
    rpmts ts = rpmtsCreate();
    rpmps ps;
#line 370 "RPM_Spec.c"

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        spec = (Spec)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Spec::check() -- spec is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 156 "RPM_Spec.xs"
    PUTBACK;
    if (ts)
        ts = rpmtsLink(ts, "Spec_check");
    else
        ts = rpmtsCreate();

    initSourceHeader(spec, NULL); /* TODO NULL => @retval *sfp     srpm file list (may be NULL) */

    if (!headerIsEntry(spec->sourceHeader, RPMTAG_REQUIRENAME)
     && !headerIsEntry(spec->sourceHeader, RPMTAG_CONFLICTNAME))
        /* XSRETURN_UNDEF; */
        return;

    (void) rpmtsAddInstallElement(ts, spec->sourceHeader, NULL, 0, NULL);

    if(rpmtsCheck(ts))
        croak("Can't check rpmts"); /* any better idea ? */

    ps = rpmtsProblems(ts);
    if (ps &&  rpmpsNumProblems(ps)) /* if no problem, return undef */
        XPUSHs(sv_2mortal(sv_setref_pv(newSVpv("", 0), "RPM::Problems", ps)));
    (void)rpmtsFree(ts);
    ts = NULL;
    SPAGAIN;
#line 403 "RPM_Spec.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Spec_build); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Spec_build)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "spec, sv_buildflags");
    {
	Spec	spec;
	SV *	sv_buildflags = ST(1);
#line 187 "RPM_Spec.xs"
    rpmts ts = rpmtsCreate();
#line 425 "RPM_Spec.c"
	int	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        spec = (Spec)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Spec::build() -- spec is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 189 "RPM_Spec.xs"
    RETVAL = _specbuild(ts, spec, sv_buildflags);
    (void)rpmtsFree(ts);
    ts = NULL;
#line 439 "RPM_Spec.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RPM__Spec_specfile); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Spec_specfile)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "spec");
    {
	Spec	spec;
	const char *	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        spec = (Spec)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Spec::specfile() -- spec is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 199 "RPM_Spec.xs"
    RETVAL = spec->specFile;
#line 469 "RPM_Spec.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_RPM__Spec_sources); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Spec_sources)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "spec, is = 0");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Spec	spec;
	int	is;
#line 208 "RPM_Spec.xs"
    struct Source *srcPtr;
#line 493 "RPM_Spec.c"

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        spec = (Spec)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Spec::sources() -- spec is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };

	if (items < 2)
	    is = 0;
	else {
	    is = (int)SvIV(ST(1));
	}
#line 210 "RPM_Spec.xs"
    for (srcPtr = spec->sources; srcPtr != NULL; srcPtr = srcPtr->next) {
        if (is && !(srcPtr->flags & is))
            continue;
        XPUSHs(sv_2mortal(newSVpv(srcPtr->source, 0)));
    }
#line 513 "RPM_Spec.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Spec_sources_url); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Spec_sources_url)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "spec, is = 0");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Spec	spec;
	int	is;
#line 221 "RPM_Spec.xs"
    struct Source * srcPtr;
#line 537 "RPM_Spec.c"

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        spec = (Spec)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Spec::sources_url() -- spec is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };

	if (items < 2)
	    is = 0;
	else {
	    is = (int)SvIV(ST(1));
	}
#line 223 "RPM_Spec.xs"
    for (srcPtr = spec->sources; srcPtr != NULL; srcPtr = srcPtr->next) {
        if (is && !(srcPtr->flags & is))
            continue;
        XPUSHs(sv_2mortal(newSVpv(srcPtr->fullSource, 0)));
    }
#line 557 "RPM_Spec.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Spec_icon); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Spec_icon)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "spec");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Spec	spec;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        spec = (Spec)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Spec::icon() -- spec is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 233 "RPM_Spec.xs"
    if (spec->sources->flags & RPMFILE_ICON) {
        char * dest = NULL;
        int len;
        len = strlen(spec->sources->source);
        dest = malloc(len);
        memcpy(dest, spec->sources->source, len);
        XPUSHs(sv_2mortal(newSVpv(dest, len)));

    }
#line 595 "RPM_Spec.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Spec_icon_url); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Spec_icon_url)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "spec");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Spec	spec;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        spec = (Spec)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Spec::icon_url() -- spec is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 247 "RPM_Spec.xs"
    if (spec->sources->flags & RPMFILE_ICON) {
        char * dest = NULL;
        int len;
        len = strlen(spec->sources->fullSource);
        dest = malloc(len);
        memcpy(dest, spec->sources->fullSource, len);
        XPUSHs(sv_2mortal(newSVpv(dest, len)));

    }
#line 633 "RPM_Spec.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_RPM__Spec); /* prototype to pass -Wmissing-prototypes */
XS(boot_RPM__Spec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        (void)newXSproto_portable("RPM::Spec::new", XS_RPM__Spec_new, file, "$;$@");
        (void)newXSproto_portable("RPM::Spec::DESTROY", XS_RPM__Spec_DESTROY, file, "$");
        (void)newXSproto_portable("RPM::Spec::srcheader", XS_RPM__Spec_srcheader, file, "$");
        (void)newXSproto_portable("RPM::Spec::binheader", XS_RPM__Spec_binheader, file, "$");
        (void)newXSproto_portable("RPM::Spec::srcrpm", XS_RPM__Spec_srcrpm, file, "$");
        (void)newXSproto_portable("RPM::Spec::binrpm", XS_RPM__Spec_binrpm, file, "$");
        (void)newXSproto_portable("RPM::Spec::check", XS_RPM__Spec_check, file, "$;$");
        (void)newXSproto_portable("RPM::Spec::build", XS_RPM__Spec_build, file, "$$");
        (void)newXSproto_portable("RPM::Spec::specfile", XS_RPM__Spec_specfile, file, "$");
        (void)newXSproto_portable("RPM::Spec::sources", XS_RPM__Spec_sources, file, "$;$");
        (void)newXSproto_portable("RPM::Spec::sources_url", XS_RPM__Spec_sources_url, file, "$;$");
        (void)newXSproto_portable("RPM::Spec::icon", XS_RPM__Spec_icon, file, "$");
        (void)newXSproto_portable("RPM::Spec::icon_url", XS_RPM__Spec_icon_url, file, "$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

