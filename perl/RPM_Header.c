/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2203 from the
 * contents of RPM_Header.xs. Do not edit this file, edit RPM_Header.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "RPM_Header.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#undef Fflush
#undef Mkdir
#undef Stat
#undef Fstat

#include <stdio.h>
#include <string.h>
#include <utime.h>

#include <rpmio.h>
#include <rpmiotypes.h>
#include <rpmcb.h>

#include <rpmtypes.h>
#include <rpmtag.h>
#include <rpmevr.h>
#include <pkgio.h>
#include "rpmdb.h"

#include "rpmds.h"
#include "rpmfi.h"
#include "rpmts.h"
#include "rpmte.h"

#include "misc.h"

#include "rpmcli.h"

#include "rpmxs.h"

#line 45 "RPM_Header.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 97 "RPM_Header.c"

XS(XS_RPM__Header_stream2header); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_stream2header)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "fp, callback = NULL");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	FILE *	fp = PerlIO_findFILE(IoIFP(sv_2io(ST(0))));
	SV *	callback;
#line 44 "RPM_Header.xs"
    FD_t fd = NULL;
    Header header;
#line 117 "RPM_Header.c"

	if (items < 2)
	    callback = NULL;
	else {
	    callback = ST(1);
	}
#line 47 "RPM_Header.xs"
    if (fp && (fd = fdDup(fileno(fp)))) {
	while (1) {
	    const char item[] = "Header";
	    const char * msg = NULL;
	    rpmRC rc;
	    header = NULL;
	    rc = rpmpkgRead(item, fd, &header, &msg);
	    switch (rc) {
	    default:
		rpmlog(RPMLOG_ERR, "%s: %s: %s\n", "rpmpkgRead", item, msg);
		/*@fallthrough@*/
	    case RPMRC_NOTFOUND:
		header = NULL;
		/*@fallthrough@*/
	    case RPMRC_OK:
		break;
	    }
	    msg = _free(msg);
	    if (header == NULL)
		break;
            if (callback != NULL && SvROK(callback)) {
                ENTER;
                SAVETMPS;
                PUSHMARK(SP);
                XPUSHs(sv_2mortal(sv_setref_pv(newSVpv("", 0), "RPM::Header", (void *)header)));
                PUTBACK;
                call_sv(callback, G_DISCARD | G_SCALAR);
                SPAGAIN;
                FREETMPS;
                LEAVE;
            } else {
                XPUSHs(sv_2mortal(sv_setref_pv(newSVpv("", 0), "RPM::Header", (void *)header)));
            }
        }
        Fclose(fd);
    }
#line 161 "RPM_Header.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Header_rpm2header); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_rpm2header)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "filename, sv_vsflags = NULL");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	filename = (char *)SvPV_nolen(ST(0));
	SV *	sv_vsflags;
#line 91 "RPM_Header.xs"
    rpmts ts = rpmtsCreate();
    rpmVSFlags vsflags = RPMVSF_DEFAULT; 
#line 186 "RPM_Header.c"

	if (items < 2)
	    sv_vsflags = NULL;
	else {
	    sv_vsflags = ST(1);
	}
#line 94 "RPM_Header.xs"
    if (sv_vsflags == NULL) /* Nothing has been passed, default is no signature */
        vsflags |= _RPMVSF_NOSIGNATURES;
    else
        vsflags = sv2constant(sv_vsflags, "rpmvsflags");
    rpmtsSetVSFlags(ts, vsflags);
    _rpm2header(ts, filename, 0);
    SPAGAIN;
    (void)rpmtsFree(ts);
    ts = NULL;
#line 203 "RPM_Header.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Header_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	Header	h;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        h = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::DESTROY() -- h is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 108 "RPM_Header.xs"
	(void)headerFree(h);
	h = NULL;
#line 232 "RPM_Header.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_RPM__Header_compare); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_compare)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "h1, h2");
    {
	Header	h1;
	Header	h2;
	int	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        h1 = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::compare() -- h1 is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };

    if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG))
        h2 = (Header)SvIV((SV*)SvRV( ST(1) ));
    else {
        warn( "RPM::Header::compare() -- h2 is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 124 "RPM_Header.xs"
	RETVAL = rpmVersionCompare(h1, h2);
#line 269 "RPM_Header.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RPM__Header__op_spaceship); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header__op_spaceship)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "h1, h2, ...");
    {
	Header	h1;
	Header	h2;
	int	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        h1 = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::_op_spaceship() -- h1 is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };

    if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG))
        h2 = (Header)SvIV((SV*)SvRV( ST(1) ));
    else {
        warn( "RPM::Header::_op_spaceship() -- h2 is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 134 "RPM_Header.xs"
	RETVAL = rpmVersionCompare(h1, h2);
#line 307 "RPM_Header.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RPM__Header_is_source_package); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_is_source_package)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	Header	h;
	int	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        h = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::is_source_package() -- h is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 142 "RPM_Header.xs"
	RETVAL = !headerIsEntry(h, RPMTAG_SOURCERPM);
#line 337 "RPM_Header.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RPM__Header_tagformat); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_tagformat)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "h, format");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Header	h;
	char *	format = (char *)SvPV_nolen(ST(1));
#line 151 "RPM_Header.xs"
	const char * s;
#line 361 "RPM_Header.c"

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        h = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::tagformat() -- h is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 153 "RPM_Header.xs"
	s =  headerSprintf(h, format, NULL, rpmHeaderFormats, NULL);
    if (s)
	    PUSHs(sv_2mortal(newSVpv((char *)s, 0)));
	s = _free(s); 
#line 374 "RPM_Header.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Header_write); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_write)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "h, fp, no_header_magic = 0");
    {
	Header	h;
	FILE *	fp = PerlIO_findFILE(IoIFP(sv_2io(ST(1))));
	int	no_header_magic;
#line 167 "RPM_Header.xs"
    FD_t fd;
#line 397 "RPM_Header.c"
	int	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        h = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::write() -- h is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };

	if (items < 3)
	    no_header_magic = 0;
	else {
	    no_header_magic = (int)SvIV(ST(2));
	}
#line 169 "RPM_Header.xs"
    RETVAL = 0;
    if (h) {
        if ((fd = fdDup(fileno(fp))) != NULL) {
	    const char item[] = "Header";
	    const char * msg = NULL;
	    rpmRC rc = rpmpkgWrite(item, fd, h, &msg);
	    if (rc != RPMRC_OK)
		rpmlog(RPMLOG_ERR, "%s: %s: %s\n", "write", item, msg);
	    msg = _free(msg);
            Fclose(fd);
            RETVAL = 1;
        }
    }
#line 427 "RPM_Header.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RPM__Header_hsize); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_hsize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "h, no_header_magic = 0");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Header	h;
	int	no_header_magic;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        h = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::hsize() -- h is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };

	if (items < 2)
	    no_header_magic = 0;
	else {
	    no_header_magic = (int)SvIV(ST(1));
	}
#line 190 "RPM_Header.xs"
    XPUSHs(sv_2mortal(newSViv(headerSizeof(h))));
#line 464 "RPM_Header.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Header_copy); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_copy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "h");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Header	h;
#line 196 "RPM_Header.xs"
    Header hcopy;
#line 487 "RPM_Header.c"

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        h = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::copy() -- h is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 198 "RPM_Header.xs"
    hcopy = headerCopy(h);
    XPUSHs(sv_2mortal(sv_setref_pv(newSVpv("", 0), "RPM::Header", (void *)hcopy)));
#ifdef HDRPMMEM
    PRINTF_NEW("RPM::Header", hcopy, hcopy->nrefs);
#endif
#line 501 "RPM_Header.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Header_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "h, no_header_magic = 0");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Header	h;
	int	no_header_magic;
#line 209 "RPM_Header.xs"
    char * string = NULL;
    char * ptr = NULL;
    int hsize = 0;
#line 527 "RPM_Header.c"

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        h = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::string() -- h is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };

	if (items < 2)
	    no_header_magic = 0;
	else {
	    no_header_magic = (int)SvIV(ST(1));
	}
#line 213 "RPM_Header.xs"
    hsize = headerSizeof(h);		/* XXX hsize includes nmagic */
    string = headerUnload(h, NULL);
    if (! no_header_magic) {
	unsigned char * hmagic = NULL;
	size_t nmagic = 0;
	(void) headerGetMagic(h, &hmagic, &nmagic);
        ptr = malloc(hsize);		/* XXX hsize includes nmagic */
        memcpy(ptr, hmagic, nmagic);
        memcpy(ptr + nmagic, string, hsize - nmagic);
    }
    XPUSHs(sv_2mortal(newSVpv(ptr ? ptr : string, hsize)));
    free(string);
    free(ptr);
#line 555 "RPM_Header.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Header_removetag); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_removetag)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "h, sv_tag");
    {
	Header	h;
	SV *	sv_tag = ST(1);
#line 232 "RPM_Header.xs"
    HE_t he = memset(alloca(sizeof(*he)), 0, sizeof(*he));
#line 577 "RPM_Header.c"
	int	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        h = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::removetag() -- h is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 234 "RPM_Header.xs"
    he->tag = 0xffffffff;
    if (SvIOK(sv_tag)) {
        he->tag = SvIV(sv_tag);
    } else if (SvPOK(sv_tag)) {
        he->tag = tagValue(SvPV_nolen(sv_tag));
    }
    if (he->tag > 0 && he->tag < 0xffffffff)
        RETVAL = headerDel(h, he, 0);
    else
        RETVAL = 1;
#line 598 "RPM_Header.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RPM__Header_addtag); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_addtag)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3)
       croak_xs_usage(cv,  "h, sv_tag, sv_tagtype, ...");
    {
	Header	h;
	SV *	sv_tag = ST(1);
	SV *	sv_tagtype = ST(2);
#line 253 "RPM_Header.xs"
    HE_t he = memset(alloca(sizeof(*he)), 0, sizeof(*he));
    char * value;
    uint32_t ivalue;
    int i;
    STRLEN len;
#line 625 "RPM_Header.c"
	int	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        h = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::addtag() -- h is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 259 "RPM_Header.xs"
    he->tag = 0xffffffff;
    if (SvIOK(sv_tag)) {
        he->tag = SvIV(sv_tag);
    } else if (SvPOK(sv_tag)) {
        he->tag = tagValue(SvPV_nolen(sv_tag));
    }
    he->t = sv2constant(sv_tagtype, "rpmtagtype");
    if (he->tag > 0 && he->tag < 0xffffffff)
        RETVAL = 1;
    else
        RETVAL = 0;
    /* if (he->tag == RPMTAG_OLDFILENAMES)
        expandFilelist(h); */
    for (i = 3; (i < items) && RETVAL; i++) {
        switch (he->t) {
            case RPM_UINT8_TYPE:
            case RPM_UINT16_TYPE:
            case RPM_UINT32_TYPE:
                ivalue = SvUV(ST(i));
		he->p.ui32p = &ivalue;
		he->c = 1;
		he->append = 1;
                RETVAL = headerPut(h, he, 0);
		he->append = 0;
                break;
            case RPM_BIN_TYPE:
                value = (char *)SvPV(ST(i), len);
		he->p.ptr = &value;
		he->c = len;
                RETVAL = headerPut(h, he, 0);
                break;
            case RPM_STRING_ARRAY_TYPE:
                value = SvPV_nolen(ST(i));
		he->p.ptr = &value;
		he->c = 1;
		he->append = 1;
                RETVAL = headerPut(h, he, 0);
		he->append = 0;
                break;
            default:
                value = SvPV_nolen(ST(i));
		he->p.ptr = value;
		he->c = 1;
		he->append = 1;
                RETVAL = headerPut(h, he, 0); 
		he->append = 0;
                break;
        }
    }
    /* if (he->tag == RPMTAG_OLDFILENAMES) {
        compressFilelist(h); 
    } */
#line 688 "RPM_Header.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RPM__Header_listtag); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_listtag)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "h");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Header	h;
#line 318 "RPM_Header.xs"
    HE_t he = memset(alloca(sizeof(*he)), 0, sizeof(*he));
    HeaderIterator hi;
#line 712 "RPM_Header.c"

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        h = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::listtag() -- h is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 321 "RPM_Header.xs"
    for (hi = headerInit(h);
	headerNext(hi, he, 0);
	he->p.ptr = _free(he->p.ptr))
    {
        XPUSHs(sv_2mortal(newSViv(he->tag)));
    }
    hi = headerFini(hi);
#line 728 "RPM_Header.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Header_hastag); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_hastag)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "h, sv_tag");
    {
	Header	h;
	SV *	sv_tag = ST(1);
#line 334 "RPM_Header.xs"
    rpmTag tag = 0xffffffff;
#line 750 "RPM_Header.c"
	int	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        h = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::hastag() -- h is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 336 "RPM_Header.xs"
    if (SvIOK(sv_tag)) {
        tag = SvIV(sv_tag);
    } else if (SvPOK(sv_tag)) {
        tag = tagValue(SvPV_nolen(sv_tag));
    }    
    if (tag < 0xffffffff)
        RETVAL = headerIsEntry(h, tag);
    else
        RETVAL = -1;
#line 770 "RPM_Header.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RPM__Header_tag); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_tag)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "h, sv_tag");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Header	h;
	SV *	sv_tag = ST(1);
#line 354 "RPM_Header.xs"
    HE_t he = memset(alloca(sizeof(*he)), 0, sizeof(*he));
#line 794 "RPM_Header.c"

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        h = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::tag() -- h is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 356 "RPM_Header.xs"
    if (SvIOK(sv_tag)) {
        he->tag = SvIV(sv_tag);
    } else if (SvPOK(sv_tag)) {
        he->tag = tagValue(SvPV_nolen(sv_tag));
    }
    if (he->tag > 0) {
        int xx = headerGet(h, he, 0);
        if (xx) {
            switch(he->t) {
                case RPM_STRING_ARRAY_TYPE:
                    {
                        int i;

                        EXTEND(SP, he->c);

                        for (i = 0; i < (int)he->c; i++) {
                            PUSHs(sv_2mortal(newSVpv(he->p.argv[i], 0)));
                        }
                    }
                break;
                case RPM_STRING_TYPE:
                    PUSHs(sv_2mortal(newSVpv(he->p.str, 0)));
                break;
                case RPM_UINT8_TYPE:
                case RPM_UINT16_TYPE:
                case RPM_UINT32_TYPE:
                    {
                        int i;

                        EXTEND(SP, he->c);

                        for (i = 0; i < (int)he->c; i++) {
                            PUSHs(sv_2mortal(newSViv(he->p.ui32p[i])));
                        }
                    }
                break;
                case RPM_BIN_TYPE:
                    PUSHs(sv_2mortal(newSVpv(he->p.ptr, he->c)));
                break;
                default:
                    croak("unknown rpm tag type %d", he->t);
            }
	    he->p.ptr = _free(he->p.ptr);
        }
    }
#line 848 "RPM_Header.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM__Header_tagtype); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_tagtype)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "h, sv_tag");
    {
	Header	h;
	SV *	sv_tag = ST(1);
#line 407 "RPM_Header.xs"
    HE_t he = memset(alloca(sizeof(*he)), 0, sizeof(*he));
#line 870 "RPM_Header.c"
	int	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        h = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::tagtype() -- h is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 409 "RPM_Header.xs"
    if (SvIOK(sv_tag)) {
        he->tag = SvIV(sv_tag);
    } else if (SvPOK(sv_tag)) {
        he->tag = tagValue(SvPV_nolen(sv_tag));
    }
    RETVAL = 0;
    if (he->tag > 0) {
        int xx = headerGet(h, he, 0);
        if (xx) {
            RETVAL = he->t;
	    he->p.ptr = _free(he->p.ptr);
	}
    }
#line 894 "RPM_Header.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RPM__Header_dependencies); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_dependencies)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "header, sv_tag");
    {
	Header	header;
	SV *	sv_tag = ST(1);
#line 430 "RPM_Header.xs"
    rpmTag tag;
#line 916 "RPM_Header.c"
	rpmds	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        header = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::dependencies() -- header is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 432 "RPM_Header.xs"
    tag = sv2constant(sv_tag, "rpmtag");
    RETVAL = rpmdsNew(header, tag, 0);
    if (RETVAL) RETVAL = rpmdsInit(RETVAL);
#line 929 "RPM_Header.c"
	ST(0) = sv_newmortal();
        sv_setref_pv( ST(0), "RPM::Dependencies", (void*)RETVAL );
    }
    XSRETURN(1);
}


XS(XS_RPM__Header_files); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM__Header_files)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "header, ts = NULL");
    {
	Header	header;
	rpmts	ts;
#line 443 "RPM_Header.xs"
#line 951 "RPM_Header.c"
	rpmfi	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG))
        header = (Header)SvIV((SV*)SvRV( ST(0) ));
    else {
        warn( "RPM::Header::files() -- header is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };

	if (items < 2)
	    ts = NULL;
	else {
    if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG))
	ts = (rpmts)SvIV((SV*)SvRV( ST(1) ));
    else {
	warn( "RPM::Header::files() -- ts is not a blessed SV reference" );
	XSRETURN_UNDEF;
    };
	}
#line 444 "RPM_Header.xs"
    if (ts)
        ts = rpmtsLink(ts, "RPM::Header::files");
    else
        ts = rpmtsCreate();
    RETVAL = rpmfiNew(ts, header, RPMTAG_BASENAMES, 0);
    if (RETVAL != NULL) RETVAL = rpmfiInit(RETVAL, 0);
    (void)rpmtsFree(ts);
    ts = NULL;
#line 980 "RPM_Header.c"
	ST(0) = sv_newmortal();
        sv_setref_pv( ST(0), "RPM::Files", (void*)RETVAL );
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_RPM__Header); /* prototype to pass -Wmissing-prototypes */
XS(boot_RPM__Header)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        (void)newXSproto_portable("RPM::Header::stream2header", XS_RPM__Header_stream2header, file, "$;$");
        (void)newXSproto_portable("RPM::Header::rpm2header", XS_RPM__Header_rpm2header, file, "$;$");
        (void)newXSproto_portable("RPM::Header::DESTROY", XS_RPM__Header_DESTROY, file, "$");
        (void)newXSproto_portable("RPM::Header::compare", XS_RPM__Header_compare, file, "$$");
        (void)newXSproto_portable("RPM::Header::_op_spaceship", XS_RPM__Header__op_spaceship, file, "$$;@");
        (void)newXSproto_portable("RPM::Header::is_source_package", XS_RPM__Header_is_source_package, file, "$");
        (void)newXSproto_portable("RPM::Header::tagformat", XS_RPM__Header_tagformat, file, "$$");
        (void)newXSproto_portable("RPM::Header::write", XS_RPM__Header_write, file, "$$;$");
        (void)newXSproto_portable("RPM::Header::hsize", XS_RPM__Header_hsize, file, "$;$");
        (void)newXSproto_portable("RPM::Header::copy", XS_RPM__Header_copy, file, "$");
        (void)newXSproto_portable("RPM::Header::string", XS_RPM__Header_string, file, "$;$");
        (void)newXSproto_portable("RPM::Header::removetag", XS_RPM__Header_removetag, file, "$$");
        (void)newXSproto_portable("RPM::Header::addtag", XS_RPM__Header_addtag, file, "$$$;@");
        (void)newXSproto_portable("RPM::Header::listtag", XS_RPM__Header_listtag, file, "$");
        (void)newXSproto_portable("RPM::Header::hastag", XS_RPM__Header_hastag, file, "$$");
        (void)newXSproto_portable("RPM::Header::tag", XS_RPM__Header_tag, file, "$$");
        (void)newXSproto_portable("RPM::Header::tagtype", XS_RPM__Header_tagtype, file, "$$");
        (void)newXSproto_portable("RPM::Header::dependencies", XS_RPM__Header_dependencies, file, "$$");
        (void)newXSproto_portable("RPM::Header::files", XS_RPM__Header_files, file, "$;$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

