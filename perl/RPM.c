/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2203 from the
 * contents of RPM.xs. Do not edit this file, edit RPM.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "RPM.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#undef Fflush
#undef Mkdir
#undef Stat
#undef Fstat

#include <stdio.h>
#include <string.h>
#include <utime.h>
#include <utime.h>

#include "rpmio.h"
#include "rpmiotypes.h"
#include "rpmcb.h"
#include "rpmmacro.h"
#include "rpmtypes.h"
#include "rpmtag.h"
#include "rpmdb.h"
#include "rpmversion.h"
#include "rpmrc.h"
#include "rpmts.h"
#include "rpmte.h"
#include "rpmevr.h"
#include "rpmcli.h"
#include "misc.h"

/* The perl callback placeholder for output err messages */
SV * log_callback_function = NULL;

/* This function is called by rpm if a callback
 * is set for for the logging system.
 * If the callback is set, rpm does not print any message,
 * and let the callback to do it */
static int logcallback(rpmlogRec rec, rpmlogCallbackData data) {
    dSP;
    if (log_callback_function) {
        int logcode = rpmlogCode();
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSVpv("logcode", 0)));
        XPUSHs(sv_2mortal(newSViv(logcode)));
        XPUSHs(sv_2mortal(newSVpv("msg", 0)));
        XPUSHs(sv_2mortal(newSVpv(rpmlogMessage(), 0)));
        XPUSHs(sv_2mortal(newSVpv("priority", 0)));
        XPUSHs(sv_2mortal(newSViv(RPMLOG_PRI(logcode))));
        PUTBACK;
        call_sv(log_callback_function, G_DISCARD | G_SCALAR);
        SPAGAIN;
        return 0;
    }
    return RPMLOG_DEFAULT;
}

#line 66 "RPM.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 118 "RPM.c"
#define crutch_stack_wrap(directive) do { \
  PUSHMARK(SP); \
  PUTBACK; \
  directive; \
  SPAGAIN; \
  PUTBACK; \
} while(0)

XS(XS_RPM_rpmversion); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM_rpmversion)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 86 "RPM.xs"
    XPUSHs(sv_2mortal(newSVpv(RPMVERSION, 0)));
#line 142 "RPM.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM_add_macro); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM_add_macro)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "macro");
    {
	char *	macro = (char *)SvPV_nolen(ST(0));
#line 92 "RPM.xs"
    rpmDefineMacro(NULL, macro, 0);
#line 163 "RPM.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_RPM_delete_macro); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM_delete_macro)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	char *	name = (char *)SvPV_nolen(ST(0));
#line 98 "RPM.xs"
	delMacro(NULL, name);
#line 183 "RPM.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_RPM_expand_macro); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM_expand_macro)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "string");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	string = (char *)SvPV_nolen(ST(0));
#line 104 "RPM.xs"
	char *ret = NULL;
#line 205 "RPM.c"
#line 106 "RPM.xs"
	ret = rpmExpand(string, NULL);
	XPUSHs(sv_2mortal(newSVpv(ret, 0)));
	free(ret);
#line 210 "RPM.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM_load_macro_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM_load_macro_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "filename");
    {
	char *	filename = (char *)SvPV_nolen(ST(0));
	int	RETVAL;
	dXSTARG;
#line 114 "RPM.xs"
    RETVAL= ! rpmLoadMacroFile(NULL, filename, 0); /* return False on error */
#line 233 "RPM.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RPM_reset_macros); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM_reset_macros)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 121 "RPM.xs"
    rpmFreeMacros(NULL);
#line 255 "RPM.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM_dump_macros); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM_dump_macros)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "fp = stdout");
    {
	FILE *	fp;

	if (items < 1)
	    fp = stdout;
	else {
	    fp = PerlIO_findFILE(IoIFP(sv_2io(ST(0))));
	}
#line 127 "RPM.xs"
    rpmDumpMacroTable(NULL, fp);
#line 282 "RPM.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_RPM_rpmvercmp); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM_rpmvercmp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "one, two");
    {
	char*	one = (char *)SvPV_nolen(ST(0));
	char*	two = (char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	RETVAL = rpmvercmp(one, two);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RPM_platformscore); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM_platformscore)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "platform");
    {
	const char *	platform = (const char *)SvPV_nolen(ST(0));
	int	RETVAL;
	dXSTARG;
#line 142 "RPM.xs"
    RETVAL=rpmPlatformScore(platform, NULL, 0);
#line 327 "RPM.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RPM_setverbosity); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM_setverbosity)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "svlevel");
    {
	SV *	svlevel = ST(0);
#line 155 "RPM.xs"
    rpmSetVerbosity(sv2constant(svlevel, "rpmlog"));
#line 348 "RPM.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_RPM_lastlogmsg); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM_lastlogmsg)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 160 "RPM.xs"
    if (GIMME_V == G_ARRAY)
    XPUSHs(sv_2mortal(newSViv(rpmlogCode())));
    XPUSHs(sv_2mortal(newSVpv(rpmlogMessage(), 0)));
#line 371 "RPM.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM_setlogfile); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM_setlogfile)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "filename");
    {
	char *	filename = (char *)SvPV_nolen(ST(0));
#line 168 "RPM.xs"
    FILE * ofp = NULL;
    FILE * fp = NULL;
#line 393 "RPM.c"
	int	RETVAL;
	dXSTARG;
#line 171 "RPM.xs"
    if (filename && *filename != 0) {
        if ((fp = fopen(filename, "a+")) == NULL) {
            XSprePUSH; PUSHi((IV)0);
            XSRETURN(1);
        }
    }
    if((ofp = rpmlogSetFile(fp)) != NULL)
        fclose(ofp);
    RETVAL=1;
#line 406 "RPM.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_RPM_setlogcallback); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM_setlogcallback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "function = NULL");
    {
	SV *	function;

	if (items < 1)
	    function = NULL;
	else {
	    function = ST(0);
	}
#line 187 "RPM.xs"
    if (function == NULL || !SvOK(function)) {
        if (log_callback_function) {
            SvREFCNT_dec(log_callback_function);
            log_callback_function = NULL;
        }
        rpmlogSetCallback(NULL, NULL);
    } else if (SvTYPE(SvRV(function)) == SVt_PVCV) {
        if (log_callback_function) {
            SvREFCNT_dec(log_callback_function);
            log_callback_function = NULL;
        }
        SvREFCNT_inc(function);
        log_callback_function = newSVsv(function);
        rpmlogSetCallback(logcallback, (rpmlogCallbackData) NULL);
    } else
        croak("First arg is not a code reference");
#line 448 "RPM.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_RPM_rpmlog); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM_rpmlog)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "svcode, msg");
    {
	SV *	svcode = ST(0);
	char *	msg = (char *)SvPV_nolen(ST(1));
#line 209 "RPM.xs"
    rpmlog(sv2constant(svcode, "rpmlog"), "%s", msg);
#line 469 "RPM.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_RPM_installsrpm); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM_installsrpm)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "filename, sv_vsflags = NULL");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	filename = (char *)SvPV_nolen(ST(0));
	SV *	sv_vsflags;
#line 216 "RPM.xs"
    rpmts ts = rpmtsCreate();
    rpmVSFlags vsflags = RPMVSF_DEFAULT;
#line 493 "RPM.c"

	if (items < 2)
	    sv_vsflags = NULL;
	else {
	    sv_vsflags = ST(1);
	}
#line 219 "RPM.xs"
    vsflags = sv2constant((sv_vsflags), "rpmvsflags");
    rpmtsSetVSFlags(ts, vsflags);
    PUTBACK;
    _installsrpms(ts, filename);
    SPAGAIN;
    (void)rpmtsFree(ts);
    ts = NULL;
#line 508 "RPM.c"
	PUTBACK;
	return;
    }
}


XS(XS_RPM_resign); /* prototype to pass -Wmissing-prototypes */
XS(XS_RPM_resign)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "passphrase, rpmfile");
    {
	char *	passphrase = (char *)SvPV_nolen(ST(0));
	char *	rpmfile = (char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;
#line 232 "RPM.xs"
    QVA_t qva = &rpmQVKArgs;
    const char *file[] = { (const char*)rpmfile, NULL };

    qva->qva_mode = RPMSIGN_ADD_SIGNATURE;
    qva->passPhrase = passphrase;

    RETVAL = rpmcliSign(NULL, qva, file);
#line 538 "RPM.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_RPM); /* prototype to pass -Wmissing-prototypes */
XS(boot_RPM)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        (void)newXSproto_portable("RPM::rpmversion", XS_RPM_rpmversion, file, "");
        (void)newXSproto_portable("RPM::add_macro", XS_RPM_add_macro, file, "$");
        (void)newXSproto_portable("RPM::delete_macro", XS_RPM_delete_macro, file, "$");
        (void)newXSproto_portable("RPM::expand_macro", XS_RPM_expand_macro, file, "$");
        (void)newXSproto_portable("RPM::load_macro_file", XS_RPM_load_macro_file, file, "$");
        (void)newXSproto_portable("RPM::reset_macros", XS_RPM_reset_macros, file, "");
        (void)newXSproto_portable("RPM::dump_macros", XS_RPM_dump_macros, file, ";$");
        (void)newXSproto_portable("RPM::rpmvercmp", XS_RPM_rpmvercmp, file, "$$");
        (void)newXSproto_portable("RPM::platformscore", XS_RPM_platformscore, file, "$");
        (void)newXSproto_portable("RPM::setverbosity", XS_RPM_setverbosity, file, "$");
        (void)newXSproto_portable("RPM::lastlogmsg", XS_RPM_lastlogmsg, file, "");
        (void)newXSproto_portable("RPM::setlogfile", XS_RPM_setlogfile, file, "$");
        (void)newXSproto_portable("RPM::setlogcallback", XS_RPM_setlogcallback, file, ";$");
        (void)newXSproto_portable("RPM::rpmlog", XS_RPM_rpmlog, file, "$$");
        (void)newXSproto_portable("RPM::installsrpm", XS_RPM_installsrpm, file, "$;$");
        (void)newXSproto_portable("RPM::resign", XS_RPM_resign, file, "$$");

    /* Initialisation Section */

#line 69 "RPM.xs"
    crutch_stack_wrap(boot_RPM__Constant(aTHX_ cv));
    crutch_stack_wrap(boot_RPM__Header(aTHX_ cv));
    crutch_stack_wrap(boot_RPM__Transaction(aTHX_ cv));
    crutch_stack_wrap(boot_RPM__PackageIterator(aTHX_ cv));
    crutch_stack_wrap(boot_RPM__Problems(aTHX_ cv));
    crutch_stack_wrap(boot_RPM__Files(aTHX_ cv));
    crutch_stack_wrap(boot_RPM__Dependencies(aTHX_ cv)); 
    crutch_stack_wrap(boot_RPM__Spec(aTHX_ cv));
	rpmReadConfigFiles(NULL, NULL);

#line 595 "RPM.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

